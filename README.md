# Тестовое задание

### Дано:
- Имеется сервис дислокации вагонов, который возвращает список вагонов, их дату прибытия на станцию, а такж привязанную накладную. Вызов сервиса эмулируется функцией get_current_dislocation()
- Имеется сервис, который предсказывает дату прибытия по накладной. На вход передается список из уникальных накладных.
Вызов сервиса эмулируется функцией get_predicted_date_by_invoices()


### Необходимо сформировать сервис (функцию api_call), которая бы:
1. Получал бы список вагонов из сервиса дислокации.
2. Формировал список накладных тех вагонов, у котороых отсутствует дата прибытия.
3. Отправлял этот список в сервис предсказания даты прибытия.
4. У всех вагонов без даты прибытия выставлял предсказанную дату прибытия.
5. Возвращал список с обновленными данными. 

### Реализация и временная сложность
Словарь none_dates_by_invoices в качестве ключей хранит имя накладной, а в качестве
значений список индексов элементов locations, у которых время прибытия None

Благодаря использованию такого словаря временная сложность функции api_call
составляет O(n), где n - количество пар вагон/накладная (не учитывая работу сервисов)

### Уточнения
Если я правильно понял, то
* Как одной накладной могут соответствовать несколько вагонов, так и одному вагону
могут соответствовать несколько накладных

### Примечания
* Есть вероятность, что в список locations попадет несколько объектов с одинаковой
парой вагон/накладная, что является коллизией
* Допустим, одному вагону соответствует несколько накладных. При этом может случиться, что
пары вагон/накладная имеют разные даты прибытия. Это может быть багом (если дата прибытия означает
дату приезда поезда в депо) либо фичей (если дата прибытия означает дату проверки груза по накладной)

P.s. Примечания относятся к работе уже написанных сервисов, а не реализованной api_call